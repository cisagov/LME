---
- name: Rollback LME to Previous Version
  hosts: localhost
  connection: local
  become: no
  vars:
    # Common variables
    install_user: "{{ ansible_user_id }}"
    lme_install_dir: "/opt/lme"
    
  # pre_tasks:
  #   - name: Display backup in progress message
  #     debug:
  #       msg: "Creating backup of current installation before rollback. This may take a few minutes..."
        
  #   - name: Run backup
  #     include_role:
  #       name: backup_lme
  #     vars:
  #       skip_prompts: true  # Skip prompts during automated backup
        
  tasks:
    - name: Get Podman graphroot location
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        podman info --format "{{ '{{' }}.Store.GraphRoot{{ '}}' }}"
      args:
        executable: /bin/bash
      register: podman_graphroot
      become: yes
      
    - name: Set backup directory
      set_fact:
        backup_base_dir: "{{ backup_dir | default(podman_graphroot.stdout) }}"
      
    - name: Get list of available backups
      find:
        paths: "{{ backup_base_dir }}/backups"
        patterns: "20*"
        file_type: directory
      register: available_backups
      
    - name: Debug backup paths
      debug:
        msg: "Found {{ available_backups.files | length }} backups in {{ backup_base_dir }}/backups"
        
    - name: Create backup paths list
      set_fact:
        backup_paths: "{{ available_backups.files | sort(attribute='path') | map(attribute='path') | list }}"

    - name: Show backup list
      debug:
        msg: "{{ dict(range(1, backup_paths|length + 1) | zip(backup_paths)) }}"
      
    - name: Prompt for backup selection
      pause:
        prompt: |
          Please enter the number of the backup to restore from (1-{{ available_backups.files | length }}):
          Note: Backups are sorted by date, with the newest backup at the bottom.
      register: backup_selection
      
    - name: Validate backup selection
      fail:
        msg: "Invalid selection. Please enter a number between 1 and {{ available_backups.files | length }}"
      when: backup_selection.user_input | int < 1 or backup_selection.user_input | int > available_backups.files | length
      
    - name: Set selected backup path
      set_fact:
        backup_dir: "{{ backup_paths[backup_selection.user_input | int - 1] }}"
      
    - name: Verify backup exists
      stat:
        path: "{{ backup_dir }}"
      register: backup_stat
      
    - name: Fail if no backup found
      fail:
        msg: "No backup found at {{ backup_dir }}"
      when: not backup_stat.stat.exists
      
    - name: Check for volume backups
      stat:
        path: "{{ backup_dir }}/volumes"
      register: volume_backup_dir
      
    - name: Stop LME service
      systemd:
        name: lme
        state: stopped
      become: yes
      
    - name: Wait for containers to stop
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        podman ps -a --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "lme" || true
      args:
        executable: /bin/bash
      register: running_containers
      become: yes
      until: running_containers.stdout_lines | length == 0
      retries: 12
      delay: 5
      ignore_errors: yes
      
    - name: Rename current LME installation
      shell: |
        if [ -d "{{ lme_install_dir }}" ]; then
          TIMESTAMP="{{ ansible_date_time.iso8601_basic_short }}"
          BACKUP_PATH="{{ lme_install_dir }}_${TIMESTAMP}"
          cp -a "{{ lme_install_dir }}" "${BACKUP_PATH}"
          echo "Backup of current installation created successfully to ${BACKUP_PATH}"
        else
          echo "WARNING: No existing LME installation found at {{ lme_install_dir }}"
        fi
      args:
        executable: /bin/bash
      become: yes
      register: current_lme_backup
      
    - name: Backup current volumes
      block:
        - name: Get list of current volumes
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            podman volume ls --format "{{ '{{' }}.Name{{ '}}' }}" | grep "^lme_"
          args:
            executable: /bin/bash
          register: current_volumes
          become: yes

        - name: Create volume backup directory
          file:
            path: "{{ backup_base_dir }}/backups/volumes_backup_{{ ansible_date_time.iso8601_basic_short }}"
            state: directory
          become: yes
          when: current_volumes.stdout_lines | length > 0

        - name: Backup each volume
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            VOLUME_PATH=$(podman volume inspect "{{ item }}" --format "{{ '{{' }}.Mountpoint{{ '}}' }}")
            BACKUP_DIR="{{ backup_base_dir }}/backups/volumes_backup_{{ ansible_date_time.iso8601_basic_short }}/{{ item }}"
            mkdir -p "${BACKUP_DIR}"
            if [ -d "$VOLUME_PATH" ] && [ "$(ls -A $VOLUME_PATH)" ]; then
              mv "$VOLUME_PATH"/* "${BACKUP_DIR}/" 2>/dev/null || true
              echo "Moved contents of volume {{ item }} to ${BACKUP_DIR} (will be deleted after restore)"
            else
              echo "Volume {{ item }} is empty or does not exist, skipping backup"
            fi
          args:
            executable: /bin/bash
          loop: "{{ current_volumes.stdout_lines }}"
          become: yes
          register: volume_backup_result
          when: current_volumes.stdout_lines | length > 0

        - name: Display volume backup results
          debug:
            msg: "{{ item.stdout_lines | join('\n') }}"
          loop: "{{ volume_backup_result.results }}"
          when: volume_backup_result is defined and item.stdout_lines | length > 0

      rescue:
        - name: Display error if no volumes found
          debug:
            msg: "No LME volumes found to backup"
      
    - name: Verify backup can be read
      stat:
        path: "{{ backup_dir }}/lme"
        get_checksum: no
      register: lme_backup_check
      become: yes
      
    - name: Validate backup directory
      fail:
        msg: "The LME backup directory doesn't exist or is not accessible: {{ backup_dir }}/lme"
      when: not lme_backup_check.stat.exists or not lme_backup_check.stat.isdir
      
    - name: Remove the current installation if backup and validation succeeded
      shell: |
        if [ -d "{{ lme_install_dir }}" ]; then
          rm -rf "{{ lme_install_dir }}"
          echo "Removed current installation at {{ lme_install_dir }}"
        fi
      args:
        executable: /bin/bash
      become: yes
      when: current_lme_backup is success and lme_backup_check.stat.exists
      
    - name: Create rollback status file
      copy:
        dest: "/tmp/lme_rollback_{{ ansible_date_time.iso8601_basic_short }}.status"
        content: |
          Rollback started: {{ ansible_date_time.iso8601 }}
          Original installation backup: {{ 'SUCCESS' if current_lme_backup is success else 'FAILED' }}
          Rollback source: {{ backup_dir }}
          Status: IN PROGRESS
      become: yes
      
    - name: Restore LME installation
      shell: "mkdir -p {{ lme_install_dir }}; cp -a {{ backup_dir }}/lme/. {{ lme_install_dir }}/; if [ $? -eq 0 ]; then echo 'LME installation restored successfully'; exit 0; else echo 'Failed to restore LME installation'; exit 1; fi"
      args:
        executable: /bin/bash
      become: yes
      when: backup_stat.stat.exists
      register: restore_result
      
    - name: Extract version from backup status file
      shell: |
        if [ -f "{{ backup_dir }}/backup_status.txt" ]; then
          grep "^LME version:" "{{ backup_dir }}/backup_status.txt" | cut -d':' -f2 | tr -d ' ' || echo "2.0.2"
        else
          echo "2.0.2"
        fi
      register: backup_version
      become: yes

    - name: Check for containers.txt file
      stat:
        path: "{{ lme_install_dir }}/config/containers.txt"
      register: containers_file
      become: yes
      
    - name: Pull containers
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        podman pull {{ item }}
      args:
        executable: /bin/bash
      loop: "{{ lookup('file', lme_install_dir + '/config/containers.txt').splitlines() }}"
      register: pull_result
      become: yes
      retries: 3
      delay: 5
      until: pull_result is not failed
      ignore_errors: yes
      when: containers_file.stat.exists
      
    - name: Display container pull errors
      debug:
        msg: "Failed to pull container: {{ item.item }}"
      loop: "{{ pull_result.results }}"
      when: item is failed
      loop_control:
        label: "{{ item.item }}"
      
    - name: Tag containers
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        podman image tag {{ item }} {{ item.split('/')[-1].split(':')[0] }}:LME_LATEST
      args:
        executable: /bin/bash
      loop: "{{ lookup('file', lme_install_dir + '/config/containers.txt').splitlines() }}"
      register: tag_result
      become: yes
      retries: 3
      delay: 5
      until: tag_result is not failed
      ignore_errors: yes
      when: containers_file.stat.exists
      
    - name: Display container tag errors
      debug:
        msg: "Failed to tag container: {{ item.item }}"
      loop: "{{ tag_result.results }}"
      when: item is failed
      loop_control:
        label: "{{ item.item }}"
      
    - name: Restore volume backups if available
      block:
        - name: Get list of volume backups
          find:
            paths: "{{ backup_dir }}/volumes"
            file_type: directory
          register: volume_dirs
          
        - name: Display volumes to restore
          debug:
            msg: "Found {{ volume_dirs.files | length }} volume backups to restore"
            
        - name: Get volume names
          set_fact:
            volume_names: "{{ volume_dirs.files | map(attribute='path') | map('basename') | list }}"
          
        - name: Validate volume names exist
          fail:
            msg: "No volume backups found in {{ backup_dir }}/volumes"
          when: volume_names | length == 0

        - name: Stop LME service before volume restoration
          systemd:
            name: lme
            state: stopped
          become: yes

        - name: Wait for containers to stop
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            podman ps -a --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "lme" || true
          args:
            executable: /bin/bash
          register: running_containers
          become: yes
          until: running_containers.stdout_lines | length == 0
          retries: 12
          delay: 5

        - name: Remove existing volumes
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            if podman volume exists "{{ item }}"; then
              podman volume rm "{{ item }}"
            fi
          args:
            executable: /bin/bash
          loop: "{{ volume_names }}"
          become: yes
          register: volume_remove_result

        - name: Create new volumes
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            podman volume create "{{ item }}"
          args:
            executable: /bin/bash
          loop: "{{ volume_names }}"
          become: yes
          register: volume_create_result

        - name: Get volume mount points
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            podman volume inspect "{{ item }}" --format "{{ '{{' }}.Mountpoint{{ '}}' }}"
          args:
            executable: /bin/bash
          loop: "{{ volume_names }}"
          register: volume_paths
          become: yes

        - name: Restore volume data
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            VOLUME_PATH=$(podman volume inspect "{{ item.item }}" --format "{{ '{{' }}.Mountpoint{{ '}}' }}")
            BACKUP_DIR="{{ backup_dir }}/volumes/{{ item.item }}/data"
            
            if [ -d "$BACKUP_DIR" ]; then
              # Copy the backup data to the volume
              cp -a "$BACKUP_DIR/." "$VOLUME_PATH/"
              if [ $? -eq 0 ]; then
                echo "Restored {{ item.item }} to ${VOLUME_PATH}"
                exit 0
              else
                echo "Failed to restore {{ item.item }}"
                exit 1
              fi
            else
              echo "No backup found for {{ item.item }}"
              exit 1
            fi
          args:
            executable: /bin/bash
          loop: "{{ volume_paths.results }}"
          become: yes
          register: volume_restore_result

        - name: Set volume list for verification
          set_fact:
            volume_list: "{{ volume_names | join(' ') }}"

        - name: Set expected empty volumes
          set_fact:
            expected_empty_volumes:
              - lme_backups
              - lme_wazuh_var_multigroups
              - lme_elastalert2_logs

        - name: Verify volume restoration
          shell: |
            export PATH=$PATH:/nix/var/nix/profiles/default/bin
            VOLUME_PATH=$(podman volume inspect "{{ item }}" --format "{{ '{{' }}.Mountpoint{{ '}}' }}")
            if [ -d "$VOLUME_PATH" ]; then
              if [ "$(ls -A "$VOLUME_PATH")" ]; then
                echo "{\"msg\": \"Volume {{ item }} exists and is not empty at $VOLUME_PATH\", \"status\": \"success\"}"
                exit 0
              else
                if [[ " {{ expected_empty_volumes | join(' ') }} " =~ " {{ item }} " ]]; then
                  echo "{\"msg\": \"Volume {{ item }} exists and is empty as expected at $VOLUME_PATH\", \"status\": \"success\"}"
                  exit 0
                else
                  echo "{\"msg\": \"Volume {{ item }} exists but is empty at $VOLUME_PATH\", \"status\": \"error\"}"
                  exit 1
                fi
              fi
            else
              echo "{\"msg\": \"Volume {{ item }} not found at $VOLUME_PATH\", \"status\": \"error\"}"
              exit 1
            fi
          args:
            executable: /bin/bash
          loop: "{{ volume_names }}"
          become: yes
          register: volume_verify_result
          ignore_errors: yes

        - name: Set initial failed volumes
          set_fact:
            failed_volumes: "{{ volume_verify_result.results | selectattr('rc', 'ne', 0) | map(attribute='item') | list }}"

        - name: Filter out expected empty volumes
          set_fact:
            failed_volumes: "{{ failed_volumes | difference(expected_empty_volumes) }}"

        - name: Display volume verification results
          debug:
            msg: "{{ item.stdout_lines }}"
          loop: "{{ volume_verify_result.results }}"
          when: item.stdout_lines | length > 0

        - name: Fail if volume verification failed
          fail:
            msg: |
              Volume verification failed. The following volumes may not have been restored properly:
              {% for volume in failed_volumes %}- {{ volume }}
              {% endfor %}
              
              Please check the backup files in {{ backup_dir }}/volumes/ for these volumes.
              
              Note: The following volumes are expected to be empty and were not considered failures:
              {% for volume in expected_empty_volumes %}- {{ volume }}
              {% endfor %}
          when: failed_volumes | length > 0

        - name: Update status to post-volume-restore
          copy:
            dest: "/tmp/lme_rollback_{{ ansible_date_time.iso8601_basic_short }}.status"
            content: |
              Rollback started: {{ ansible_date_time.iso8601 }}
              Original installation backup: {{ 'SUCCESS' if current_lme_backup is success else 'FAILED' }}
              Rollback source: {{ backup_dir }}
              Status: IN PROGRESS
              Stage: POST_VOLUME_RESTORE
              Volumes restored: {{ volume_names | join(', ') }}
              Failed volumes: {{ failed_volumes | join(', ') if failed_volumes | length > 0 else 'None' }}
              Expected empty volumes: {{ expected_empty_volumes | join(', ') }}
          become: yes
        
      when: volume_backup_dir.stat is defined and volume_backup_dir.stat.exists
      
    - name: Start LME service
      systemd:
        name: lme
        state: started
      become: yes
      register: service_start_result
      
    - name: Wait for containers to start
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        podman ps --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "lme" || true
      args:
        executable: /bin/bash
      register: started_containers
      become: yes
      until: started_containers.stdout_lines | length > 0
      retries: 24
      delay: 10
      ignore_errors: yes
      
    - name: Wait for services to be ready
      pause:
        seconds: 60
      
    - name: Check container status
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        echo "=== Running Containers ==="
        podman ps --format "{{ '{{' }}.Names{{ '}}' }}: {{ '{{' }}.Status{{ '}}' }}" | grep -E "lme" || echo "No LME containers running"
        echo -e "\n=== Container Logs ==="
        for container in $(podman ps -a --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "lme"); do
          echo "--- $container logs ---"
          podman logs --tail 5 $container
        done
      args:
        executable: /bin/bash
      register: container_status
      become: yes
      changed_when: false

    - name: Display container status
      debug:
        msg: "{{ container_status.stdout_lines | join('\n') }}"

    - name: Verify services are running
      shell: |
        export PATH=$PATH:/nix/var/nix/profiles/default/bin
        LME_CONTAINERS=$(podman ps --format "{{ '{{' }}.Names{{ '}}' }}" | grep -E "lme" || true)
        CONTAINER_COUNT=$(echo "$LME_CONTAINERS" | grep -v '^$' | wc -l)
        if [ "$CONTAINER_COUNT" -eq 5 ]; then
          echo "All expected LME services are running"
          exit 0
        else
          echo "Only $CONTAINER_COUNT of 5 expected LME services are running"
          exit 1
        fi
      args:
        executable: /bin/bash
      register: containers_status
      become: yes
      changed_when: false

    - name: Fail if not all services are running
      fail:
        msg: "Not all expected LME services are running. Only {{ containers_status.stdout_lines | select('match', '^lme') | list | length }} of 5 expected services were detected."
      when: containers_status.rc != 0
      
    - name: Collect rollback results
      set_fact:
        install_status: "{{ 'Success' if backup_stat.stat.exists else 'Failed' }}"
        volumes_status: "{{ 'Success' if volume_restore_result is success else 'Failed' }}"
        containers_status: "{{ 'Success' if containers_status.stdout_lines | length > 0 else 'Failed' }}"
      
    - name: Update rollback status file
      copy:
        dest: "/tmp/lme_rollback_{{ ansible_date_time.iso8601_basic_short }}.status"
        content: |
          Rollback completed: {{ ansible_date_time.iso8601 }}
          Original installation backup: {{ 'SUCCESS' if current_lme_backup is success else 'FAILED' }}
          Rollback source: {{ backup_dir }}
          
          Restore status:
          - LME installation: {{ install_status }}
          - Containers pull/tag: {{ 'Success' if pull_result is success and tag_result is success else 'Partial - Some errors occurred' }}
          - Volumes: {{ volumes_status }}
          - Containers running: {{ containers_status }}
          
          Overall status: {{ 'SUCCESS' if install_status == 'Success' and containers_status == 'Success' and service_start_result is success else 'PARTIAL - See details above' }}
          
          Recovery instructions:
          {% if install_status != 'Success' %}
          If the rollback failed during installation:
          1. Stop the LME service: systemctl stop lme
          2. Remove the failed installation: rm -rf {{ lme_install_dir }}
          3. Restore from backup: mv {{ lme_install_dir }}_{{ ansible_date_time.iso8601_basic_short }} {{ lme_install_dir }}
          4. Start the service: systemctl start lme
          {% elif tag_result is failed %}
          If the rollback failed during container tagging:
          1. Stop the LME service: systemctl stop lme
          2. Remove the failed installation: rm -rf {{ lme_install_dir }}
          3. Restore from backup: mv {{ lme_install_dir }}_{{ ansible_date_time.iso8601_basic_short }} {{ lme_install_dir }}
          4. Start the service: systemctl start lme
          {% elif volumes_status != 'Success' %}
          If the rollback failed during volume restoration:
          1. Stop the LME service: systemctl stop lme
          2. For each volume:
             a. Remove the current volume: podman volume rm [volume_name]
             b. Create a new volume: podman volume create [volume_name]
             c. Restore from backup: cp -a {{ backup_base_dir }}/backups/volumes_backup_{{ ansible_date_time.iso8601_basic_short }}/[volume_name]/* [volume_mountpoint]/
          3. Start the service: systemctl start lme
          {% elif containers_status != 'Success' %}
          If the rollback failed during container startup:
          1. Check container logs: podman logs [container_name]
          2. Verify container images: podman images
          3. Try restarting the service: systemctl restart lme
          {% endif %}

          Cleanup instructions (after confirming successful rollback):
          1. Remove the original installation backup: rm -rf {{ lme_install_dir }}_{{ ansible_date_time.iso8601_basic_short }}
          2. Remove the original volumes backup: rm -rf {{ backup_base_dir }}/backups/volumes_backup_{{ ansible_date_time.iso8601_basic_short }}
      become: yes
      
    - name: Rollback complete message
      debug:
        msg: |
          LME has been rolled back to the previous version.
          Original installation backed up to: {{ lme_install_dir }}_{{ ansible_date_time.iso8601_basic_short }}
          Restored from: {{ backup_dir }}
          
          Restore status:
          - LME installation: {{ install_status }}
          - Containers pull/tag: {{ 'Success' if pull_result is success and tag_result is success else 'Partial - Some errors occurred' }}
          - Volumes: {{ volumes_status }}
          - Containers running: {{ containers_status }}
          
          Overall status: {{ 'SUCCESS' if install_status == 'Success' and containers_status == 'Success' and service_start_result is success else 'PARTIAL - See details above' }}
          
          A detailed status report has been saved to: /tmp/lme_rollback_{{ ansible_date_time.iso8601_basic_short }}.status

    - name: Read cleanup instructions from status file
      command: cat "/tmp/lme_rollback_{{ ansible_date_time.iso8601_basic_short }}.status"
      register: status_file
      changed_when: false

    - name: Show cleanup instructions
      debug:
        msg: "{{ dict(range(1, status_file.stdout_lines|length + 1) | zip(status_file.stdout_lines)) }}" 